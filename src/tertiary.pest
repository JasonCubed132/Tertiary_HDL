file = { SOI ~ module_header ~ module_body? ~ module_footer ~ EOI }

module_header = { "module" ~ ident ~ parameters? ~ ports? ~ ";" }
module_body = { top_level_stmt ~ (top_level_stmt)* }
module_footer = { "endmodule" }

parameters = { "#(" ~ param_block ~ ")"}
param_block = { param_line ~ ("," ~ param_line)* }
param_line = { "parameter" ~ ident ~ "=" ~ value }

ports = {"(" ~ io_block ~ ")"}
io_block = { io_line ~ ("," ~ io_line)* }
io_line = { io_type ~ var_decl }
io_type = { ("input" | "output" | "inout") }

top_level_stmt = { var_decl | block_decl }
var_decl = { data_type ~ data_size? ~ csv_idents }
block_decl = { assign_block | always_block }

assign_block = { "assign" ~ ident ~ "=" ~ expr ~ ";"}
always_block = { "always" ~ sensitivity_list ~ block }
block = { ("begin" ~ stmts ~ "end") | stmt}
stmts = { stmt ~ (stmt)* }
stmt = { var_assign | if_block }
var_assign = { ident_write ~ "=" ~ expr ~ ";" }
if_block = { "if" ~ expr ~ block }

sensitivity_list = { "@(" ~ sensitivity_list_inner ~  ")"}
sensitivity_list_inner = _{ csv_idents | "*" | time_based_sensitivity_list }
time_based_sensitivity_list = _{ time_based_sensitivity ~ ("or" ~ time_based_sensitivity)* }
time_based_sensitivity = _{ ("posedge" | "negedge") ~ ident }

data_type = { ("reg" | "wire") }
data_size = { "[" ~ value ~ ":" ~ value ~"]"}
csv_idents = { ident ~ ("," ~ !(io_type) ~ ident)* }

expr  = { expr2 }
expr2 = { expr3 ~ ("^" ~ expr)? }
expr3 = { expr4 ~ ("|" ~ expr)? }
expr4 = _{ value | indexed_ident | ident | ("(" ~ expr ~ ")") }

ident_write = _{ indexed_ident | ident }

indexed_ident = @{ ident ~ index }
index = { "[" ~ (single_index | range_index | span_index )~ "]"}
single_index = { value }
range_index = { value ~ ":" ~ value }
span_index = { value ~ ("-:" | "+:") ~ value }

value = @{ (num ~ "'" ~ value_type)? ~ num }
value_type = { "b" | "o" | "d" | "h" }

ident = @{ char+ ~ (char+ | digit+ | "_")* }
num = @{ digit+ }

digit = { ASCII_DIGIT }
char = { ASCII_ALPHA }

WHITESPACE = _{ " " | "\r" | "\n" }



source_text = { description+ }
description = { module | UDP }
module = { 
       ("module" ~ name_of_module ~ list_of_ports? ~ ";" ~ module_item* ~ "endmodule")
    |  ("macromodule" ~ name_of_module ~ list_of_ports? ~ ";" ~ module_item* ~ "endmodule")
}
name_of_module = { IDENTIFIER }
list_of_ports = { port ~ ("," ~ port)* }
port = { port_expression? | ("." ~ name_of_port ~ "(" ~ port_expression? ~ ")") }
port_expression = { port_reference | ("{" ~ port_reference ~ ("," ~ port_reference)* ~ "}")}
port_reference = {
      name_of_variable
    | (name_of_variable ~ constant_expression?)
    | (name_of_variable ~ "[" ~ constant_expression ~ ":" ~ constant_expression ~ "]")
}
name_of_port = { IDENTIFIER }
name_of_variable = { IDENTIFIER }

module_item = {
      parameter_declaration
    | input_declaration
    | output_declaration
    | inout_declaration
    | net_declaration
    | reg_declaration
    | time_declaration
    | integer_declaration
    | real_declaration
    | event_declaration
    | gate_declaration
    | UDP_instantiation
    | module_instantiation
    | parameter_override
    | continuous_assign
    | specify_block
    | initial_statement
    | always_statement
    | task
    | function
}

UDP = { "primitive" ~ name_of_UDP ~ "(" ~ name_of_variable ~ ("," ~ name_of_variable)* ~ ")" ~ ";" ~ UDP_declaration+ ~ UDP_initial_statement? ~ table_definition ~ "end_primitive" }
name_of_UDP = { IDENTIFIER }
UDP_declaration = {
      output_declaration
    | reg_declaration
    | input_declaration
}
UDP_initial_statement = {
    "initial" ~ output_terminal_name ~ "=" ~ init_val ~ ";"
}
init_val = {
      "1'b0"
    | "1'b1"
    | "1'bx"
    | "1'bX"
    | "1'B0"
    | "1'B1"
    | "1'Bx"
    | "1'BX"
    | "1"
    | "0"
}
output_terminal_name = { name_of_variable }
table_definition = { "table" ~ table_entries ~ "endtable" }
table_entries = {
      combinational_entry+
    | sequential_entry+
}
combinational_entry = { level_input_list ~ ":" ~ OUTPUT_SYMBOL ~ ";" }
sequential_entry = { input_list ~ ":" ~ state ~ ":" ~ next_state ~ ";" }
input_list = {
      level_input_list
    | edge_input_list
}
level_input_list = { LEVEL_SYMBOL+ }
edge_input_list = { LEVEL_SYMBOL* ~ edge ~ LEVEL_SYMBOL* }
edge = {
      ( "(" ~ LEVEL_SYMBOL ~ LEVEL_SYMBOL ~ ")")
    | EDGE_SYMBOL
}
state = { LEVEL_SYMBOL }
next_state = { OUTPUT_SYMBOL | "-" }

OUTPUT_SYMBOL = {
    "0" | "1" | "x" | "X" 
}
LEVEL_SYMBOL = {
    "0" | "1" | "x" | "X" | "?" | "b" | "B"
}
EDGE_SYMBOL =  {
    "r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
}


task = {
    "task" ~ name_of_task ~ ";" ~ tf_declaration* ~ statement_or_null ~ "endtask"
}
name_of_task = { IDENTIFIER }

function = {
    "function" ~ range_or_type? ~ name_of_function ~ ";" ~ tf_declaration+ ~ statement ~ "endfunction"
}
range_or_type = { range | "integer" | "real" }
name_of_function = { IDENTIFIER }
tf_declaration = {
    parameter_declaration
    | input_declaration
    | output_declaration
    | inout_declaration
    | reg_declaration
    | time_declaration
    | integer_declaration
    | real_declaration
}


parameter_declaration = { "parameter" ~ list_of_param_assignments ~ ";" }
list_of_param_assignments = { param_assignment ~ ("," ~ param_assignment)* }
param_assignment = { IDENTIFIER ~ "=" ~ constant_expression }

input_declaration = { "input" ~ range? ~ list_of_variables ~ ";" }
output_declaration = { "output" ~ range? ~ list_of_variables ~ ";" }
inout_declaration = { "inout" ~ range? ~ list_of_variables ~ ";" }
net_declaration = {
      (NETTYPE ~ expandrange? ~ delay? ~ list_of_variables ~ ";")
    | ("trireg" ~ charge_strength? ~ expandrange? ~ delay?)
}
list_of_variables = {
    NETTYPE ~ drive_strength? ~ expandrange? ~ delay? ~ list_of_assignments ~ ";"
}

NETTYPE = { "wire" | "tri" | "tri1" | "supply0" | "wand" | "triand" | "tri0" | "supply1" | "wor" | "trior" | "trireg" }
expandrange = {
    range
    | ("scalared" ~ range)
    | ("vectored" ~ range)
}

reg_declaration = {
    "reg" ~ range? ~ list_of_register_variables;
}
time_declaration = {
    "time" ~ list_of_register_variables ~ ";"
}
integer_declaration = {
    "integer" ~ list_of_register_variables ~ ";"
}
real_declaration = {
    "real" ~ list_of_variables ~ ";"
}
event_declaration = {
    "event" ~ name_of_event ~ ("," ~ name_of_event)* ~ ";"
}

continuous_assign = {

}